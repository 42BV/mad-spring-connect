I"!/<p>All util functions which do requests are passed through a middleware layer.
The reason the middleware layer exists is because <code class="highlighter-rouge">fetch</code> by default
does very little. <code class="highlighter-rouge">fetch</code> does not handle errors and JSON parsing
of responses. It is annoying to have to manually do this every time.</p>

<p>The middleware layer allows you to define these common behaviors once
and make use of them automatically.</p>

<p><code class="highlighter-rouge">Middleware</code> is a type with the following definition:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">type</span> <span class="nx">RequestInfo</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">url</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
  <span class="nl">method</span><span class="p">:</span> <span class="nx">Method</span><span class="p">;</span>
  <span class="nl">queryParams</span><span class="p">?:</span> <span class="nx">QueryParams</span><span class="p">;</span>
  <span class="nl">payload</span><span class="p">?:</span> <span class="nx">any</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">Middleware</span> <span class="o">=</span> <span class="p">(</span><span class="na">middleware</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">options</span><span class="p">:</span> <span class="nx">MiddlewareDetailInfo</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>Middleware is a <code class="highlighter-rouge">function</code> which takes a <code class="highlighter-rouge">Promise</code> and
returns a new <code class="highlighter-rouge">Promise</code>. What happens in the middle is
what the middleware actually does.</p>

<p>Each middleware you configure will hook into the previous
middleware in order of definition in the configuration.</p>

<p>As an optional second argument you can receive the data that
was used to construct the request that was made so you can
take further actions if needed.</p>

<h3 id="default-middleware">Default middleware</h3>

<p>Two middlewares are provided out of the box:</p>

<p>The first is <strong><em>checkStatus</em></strong> which converts all non 2xx responses to errors.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">checkStatus</span><span class="p">(</span><span class="nx">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Response</span><span class="o">&gt;</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Response</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">promise</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">status</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">&lt;=</span> <span class="mi">299</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nx">ErrorWithResponse</span><span class="p">(</span><span class="nx">response</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The second is <strong><em>parseJSON</em></strong> which converts a <code class="highlighter-rouge">Response</code> to a <code class="highlighter-rouge">JSON</code> object:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">async</span> <span class="kd">function</span> <span class="nx">parseJSON</span><span class="p">(</span><span class="nx">promise</span><span class="p">:</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Response</span><span class="o">&gt;</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">promise</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">204</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">({});</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">contentType</span> <span class="o">=</span> <span class="nx">response</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">contentType</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">contentType</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">json</span><span class="dl">'</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">@42.nl/spring-connect: Content-Type is not json, will not parse.</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="adding-middleware">Adding middleware</h3>

<p>There are a couple of rules to define your own middleware:</p>

<ol>
  <li>You must keep the chain alive, so you must either <code class="highlighter-rouge">then</code> or <code class="highlighter-rouge">catch</code>
or do <strong>both</strong> with the incoming <code class="highlighter-rouge">Promise</code>.</li>
  <li>When doing a <code class="highlighter-rouge">catch</code> you must return a rejected promise.</li>
</ol>

<p>Knowing these rules we can define a middleware which listens
to 400 errors and <code class="highlighter-rouge">alert</code>â€™s those errors:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">displayError</span><span class="p">(</span><span class="nx">promise</span><span class="p">,</span> <span class="nx">middlewareDetailInfo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">promise</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="mi">400</span><span class="p">)</span> <span class="p">{</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">alert</span><span class="p">(</span><span class="s2">`An error occurred when attempting to request </span><span class="p">${</span><span class="nx">middlewareDetailInfo</span><span class="p">.</span><span class="nx">url</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Keep the chain alive.</span>
    <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now all you need to do is call <code class="highlighter-rouge">configureMadConnect</code> and
set the middleware:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">configureMadConnect</span><span class="p">,</span> <span class="nx">checkStatus</span><span class="p">,</span> <span class="nx">parseJSON</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@42.nl/spring-connect</span><span class="dl">'</span><span class="p">;</span>

<span class="k">import</span> <span class="p">{</span> <span class="nx">authFetch</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@42.nl/authentication</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">configureMadConnect</span><span class="p">({</span>
  <span class="na">fetch</span><span class="p">:</span> <span class="nx">authFetch</span><span class="p">,</span>
  <span class="na">middleware</span><span class="p">:</span> <span class="p">[</span><span class="nx">checkStatus</span><span class="p">,</span> <span class="nx">parseJSON</span><span class="p">,</span> <span class="nx">displayError</span><span class="p">],</span>
<span class="p">});</span>
</code></pre></div></div>

<h3 id="custom-calls-with-applymiddleware">Custom calls with applyMiddleware</h3>

<p>You can create custom fetch operations but still apply the
configured middleware. This works because the applyMiddleware and getFetch
functions are both exposed:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">applyMiddleware</span><span class="p">(</span><span class="nx">getFetch</span><span class="p">()(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">options</span><span class="p">),</span> <span class="p">{</span> <span class="nx">url</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">queryParams</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">});</span>
</code></pre></div></div>

<p>This way you can control all the options that are given to
fetch method, such as the headers or body.</p>
:ET